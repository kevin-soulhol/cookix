# Fichier: .github/workflows/test.yml

name: E2E Tests

on:
  pull_request:
    types: [opened, synchronize, reopened]

env:
  # Variable globale pour le nom et le tag de l'image Docker
  IMAGE_TAG: ghcr.io/${{ github.repository_owner }}/cookix-app:${{ github.sha }}

jobs:
  e2e-tests:
    name: "Run E2E Tests with Docker Compose"
    runs-on: ubuntu-latest

    steps:
      - name: "① Checkout Code"
        uses: actions/checkout@v4

      - name: "② Setup Node.js & Cache"
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: "③ Install Dependencies"
        run: npm ci

      - name: "④ Install Playwright Browsers"
        run: npx playwright install --with-deps chromium

      - name: "⑤ Create .env file for Docker Compose"
        run: |
          cat <<EOF > .env
          SESSION_SECRET=${{ secrets.SESSION_SECRET }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          ROOT_PASSWORD=${{ secrets.ROOT_PASSWORD }}
          DATABASE_URL=mysql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@db:3306/${{ secrets.DB_NAME }}
          CHRONODRIVE_EMAIL=${{ secrets.CHRONODRIVE_EMAIL }}
          CHRONODRIVE_PASSWORD=${{ secrets.CHRONODRIVE_PASSWORD }}
          CHRONODRIVE_API_KEY=${{ secrets.CHRONODRIVE_API_KEY }}
          CHRONODRIVE_API_KEY_CART=${{ secrets.CHRONODRIVE_API_KEY_CART }}
          CHRONODRIVE_API_KEY_USER=${{ secrets.CHRONODRIVE_API_KEY_USER }}
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          PEXELS_API_KEY=${{ secrets.PEXELS_API_KEY }}
          DOCKER_IMAGE_TAG=${{ env.IMAGE_TAG }}
          EOF

      # On combine le build et le démarrage, comme le fait docker-compose
      - name: "⑥ Build and Start Docker Environment"
        run: |
          echo "Building and starting 'app' and 'db' services..."
          # L'option --wait s'assure que les conteneurs sont "healthy" avant de continuer
          docker compose -f docker-compose.prod.yml up -d --build --wait app db

      - name: "⑦ Setup Database (Migrations & Seed)"
        run: |
          echo "Running database migrations and seeding..."
          # Plus besoin de passer la variable DATABASE_URL, car elle est dans le .env
          # que le conteneur a déjà chargé au démarrage.
          docker compose -f docker-compose.prod.yml exec -T app npx prisma migrate deploy
          docker compose -f docker-compose.prod.yml exec -T app node prisma/seed.test.js

      - name: "⑧ Run Playwright Tests"
        # continue-on-error est la méthode propre pour gérer les échecs de tests
        continue-on-error: true
        id: playwright_tests
        run: npx playwright test
        env:
          PLAYWRIGHT_TEST_BASE_URL: http://localhost:3000
          # L'URL pour les tests sur le runner doit utiliser localhost
          DATABASE_URL_TEST: mysql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@localhost:3306/${{ secrets.DB_NAME }}

      - name: "⑨ Publish Test Report"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 7

      - name: "⑩ Show Logs & Cleanup on Failure"
        # Cette étape ne s'exécute qu'en cas d'échec des tests
        if: steps.playwright_tests.outcome == 'failure'
        run: |
          echo "::error::E2E tests failed. Displaying container logs:"
          docker compose -f docker-compose.prod.yml logs --no-color
          echo "Cleaning up Docker environment..."
          docker compose -f docker-compose.prod.yml down -v --remove-orphans

      - name: "⑩ Cleanup on Success"
        # Cette étape ne s'exécute qu'en cas de succès
        if: steps.playwright_tests.outcome == 'success'
        run: |
          echo "E2E tests passed. Cleaning up Docker environment..."
          docker compose -f docker-compose.prod.yml down -v --remove-orphans
